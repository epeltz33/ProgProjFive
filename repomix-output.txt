This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-04T20:37:38.063Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.settings/
  org.eclipse.jdt.core.prefs
src/
  .idea/
    .gitignore
    misc.xml
    modules.xml
    vcs.xml
  adts/
    BinarySearchTree.java
    LLQ.java
    LLStack.java
  apps/
    AlphaBravoCharlie.java
    Golfer.java
    LeaderBoard.java
  interfaces/
    BSTInterface.java
    QueueInterface.java
    StackInterface.java
  iterators/
    BSTIterator.java
  nodes/
    BSTNode.java
    DLLNode.java
    LLNode.java
  ProgProjFive.iml
.classpath
.project

================================================================
Repository Files
================================================================

================
File: .settings/org.eclipse.jdt.core.prefs
================
eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
org.eclipse.jdt.core.compiler.compliance=1.8
org.eclipse.jdt.core.compiler.debug.lineNumber=generate
org.eclipse.jdt.core.compiler.debug.localVariable=generate
org.eclipse.jdt.core.compiler.debug.sourceFile=generate
org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
org.eclipse.jdt.core.compiler.source=1.8

================
File: src/.idea/.gitignore
================
# Default ignored files
/shelf/
/workspace.xml
# Editor-based HTTP Client requests
/httpRequests/
# Datasource local storage ignored files
/dataSources/
/dataSources.local.xml

================
File: src/.idea/misc.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectRootManager" version="2" languageLevel="JDK_23" default="true" project-jdk-name="openjdk-23" project-jdk-type="JavaSDK">
    <output url="file://$PROJECT_DIR$/out" />
  </component>
</project>

================
File: src/.idea/modules.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/ProgProjFive.iml" filepath="$PROJECT_DIR$/ProgProjFive.iml" />
    </modules>
  </component>
</project>

================
File: src/.idea/vcs.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings" defaultProject="true" />
</project>

================
File: src/adts/BinarySearchTree.java
================
package adts;

import java.util.Iterator;
import java.util.ArrayList;

import interfaces.*;
import iterators.BSTIterator;
import nodes.BSTNode;


enum TraversalType {
	PREORDER, INORDER, POSTORDER, REVORDER, RANDOM
}


public class BinarySearchTree<T extends Comparable<T>> 
             implements BSTInterface<T>, Iterable<T> {
	
	protected BSTNode<T> root;   
	
	boolean found;   // used by remove
	
	T[] rebalanceArray;  // for rebalancing the tree
	int rebalanceIndex;  //           "
	
	// for traversals
	protected TraversalType travType;
	ArrayList<T> travList;
	

	public BinarySearchTree() {
		root = null;
		travType = TraversalType.INORDER;
	}
	
	
	public void add (T element) {
		root = recAdd(element, root);
    }
	
	private BSTNode<T> recAdd(T element, BSTNode<T> tree) {
		if (tree == null) {
			tree = new BSTNode<T>(element);
		}
		else {
			if (element.compareTo(tree.getData()) <= 0) {
				tree.setLeft(recAdd(element, tree.getLeft()));  // add to left subtree
				
			}
			else {
				tree.setRight(recAdd(element, tree.getRight()));  // add to right subtree
		    }
		}
		return tree;
	}
	
	
	public boolean remove (T element) {
		root = recRemove(element, root);
		return found;
	}
	  
	private BSTNode<T> recRemove(T element, BSTNode<T> tree) {
		if (tree == null) {
			found = false;
		}
		else {
			if (element.compareTo(tree.getData()) < 0) {
				tree.setLeft(recRemove(element, tree.getLeft()));
			}
			else {
				if (element.compareTo(tree.getData()) > 0) {
					tree.setRight(recRemove(element, tree.getRight()));
				}
				else {
					tree = removeNode(tree);
					found = true;
				}
			}
		}
		return tree;
	}

	private BSTNode<T> removeNode(BSTNode<T> tree) {
		
		T payload;
			  
		if (tree.getLeft() == null) {
			return tree.getRight();
		}
		else {
			if (tree.getRight() == null) {
				return tree.getLeft();
			}
			else {
				payload = getPredecessor(tree.getLeft());
				tree.setData(payload);
				tree.setLeft(recRemove(payload, tree.getLeft()));
				return tree;
			}
		}
	}

	private T getPredecessor(BSTNode<T> tree) {
		while (tree.getRight() != null) {
			tree = tree.getRight();
		}
		return tree.getData();
	}

	  
	public int size() {
		return recSize(root);
	}
	
	private int recSize(BSTNode<T> tree) {
		if (tree == null) {
			return 0;
		}
		else {
			return recSize(tree.getLeft()) + recSize(tree.getRight()) + 1;
		}
	}
	
	// this implementation of a size operation demonstrates that
	// it is possible to visit all the nodes of the tree without recursion
	public int size2() {
		int count = 0;
		if (root != null) {
			LLStack<BSTNode<T>> hold = new LLStack<BSTNode<T>>();
			BSTNode<T> currNode;
			hold.push(root);
			while (!hold.isEmpty()) {
				currNode = hold.peek();
				hold.pop();
				count++;
				if (currNode.getLeft() != null) {
					hold.push(currNode.getLeft());
				}
				if (currNode.getRight() != null) {
					hold.push(currNode.getRight());
				}
			}
		}
		return count;
	}

	  
	public boolean isEmpty() {
		return (root == null);
	}
	
	
	public boolean contains (T element) {
		return recContains(element, root);
	}
	
	private boolean recContains(T element, BSTNode<T> tree) {
		if (tree == null) {
			return false;
		}
		else {
	    	if (element.compareTo(tree.getData()) < 0) {
	    		return recContains(element, tree.getLeft());  // search left subtree
	    	}
	        else {
	        	if (element.compareTo(tree.getData()) > 0) {
	        		return recContains(element, tree.getRight());  // search right subtree
	        	}
	            else {
	                return true;  // element.compareTo(tree, the subtree's root) == 0
	            }
	        }
		}
	}

	
	public T get(T element) {
		return recGet(element, root);
	}
	
	private T recGet(T element, BSTNode<T> tree) {
		if (tree == null) {
			return null;
		}
		else {
			if (element.compareTo(tree.getData()) < 0) {
				return recGet(element, tree.getLeft());  // get from left subtree
			}
			else {
				if (element.compareTo(tree.getData()) > 0) {
					return recGet(element, tree.getRight());  // get from right subtree
				}
				else {
					return tree.getData();  // element is found!
				}
			}
		}
	}
	
	// -------- traversal related code ----------------
	
	public void setTraversalType(String order) {
		if (order.equalsIgnoreCase("pre")) {
			travType = TraversalType.PREORDER;
		}
		else {
			if (order.equalsIgnoreCase("in")) {
				travType = TraversalType.INORDER;
			}
			else {
				if (order.equalsIgnoreCase("post")) {
					travType = TraversalType.POSTORDER;
				}
				else {
					travType = TraversalType.INORDER;
				}
			}
		}
	}
	
	// iterator object instantiation for enhanced for loop:
	public Iterator<T> iterator() {
		
		travList = new ArrayList<>(size());
		
		switch (travType) {
		case INORDER:
			inOrder(root);
			break;
		case PREORDER:
			preOrder(root);
			break;
		case POSTORDER:
			postOrder(root);
			break;
		}

		return new BSTIterator(travList); 
	}
	
	private void inOrder(BSTNode<T> tree) {
		if (tree != null) {
			inOrder(tree.getLeft());
			travList.add(tree.getData());
			inOrder(tree.getRight());
		}
	}
	
	private void preOrder(BSTNode<T> tree) {
		if (tree != null) {
			travList.add(tree.getData());
			preOrder(tree.getLeft());
			preOrder(tree.getRight());
		}
	}
	
	private void postOrder(BSTNode<T> tree) {
		if (tree != null) {
			postOrder(tree.getLeft());
			postOrder(tree.getRight());
			travList.add(tree.getData());
		}
	}

	// ------------------------------------------------

	
	
	public void rebalance() {
		rebalanceArray = (T[]) new Comparable[size()];
		rebalanceIndex = -1;
		fillRebalanceArray(root);
		root = null;
		recRebalance(0, rebalanceArray.length - 1);
	}
	
	private void fillRebalanceArray(BSTNode<T> tree) {
		if (tree != null) {
			fillRebalanceArray(tree.getLeft());
			rebalanceArray[++rebalanceIndex] = tree.getData();
			fillRebalanceArray(tree.getRight());
		}
	}
	
	private void recRebalance(int first, int last) {
		if (first <= last) {
			int mid = first + (last - first) / 2;
			root = recAdd(rebalanceArray[mid], root);
			recRebalance(first, mid-1);
			recRebalance(mid+1, last);
		}
	}
	
}

================
File: src/adts/LLQ.java
================
package adts;

import interfaces.QueueInterface;
import nodes.LLNode;

public class LLQ<E> implements QueueInterface<E> {
	
	LLNode<E> front;
	LLNode<E> rear;

	@Override
	public void enqueue(E element) {
		LLNode<E> newNode = new LLNode<>(element);
		if (rear == null) {
			rear = front = newNode;
		}
		else {
			rear.setNext(newNode);
			rear = newNode;
		}
	}

	@Override
	public E dequeue() {
		E temp = front.getData();
		front = front.getNext();
		if (front == null) {
			rear = null;
		}
		return temp;
	}

	
	@Override
	public boolean isEmpty() {
		return rear == null;
	}

	@Override
	public boolean isFull() {
		return false;
	}
	
	public String toString() {
		StringBuilder qStr = new StringBuilder("queue, front to rear: ");
		LLNode<E> ptr  = front;
		while (ptr != null) {
			qStr.append(ptr.getData() + " ");
			ptr = ptr.getNext();
		}
		return qStr.toString();
	}

}

================
File: src/adts/LLStack.java
================
package adts;

import interfaces.StackInterface;
import nodes.LLNode;

public class LLStack<E> implements StackInterface<E> {
	
	LLNode<E> top;

	@Override
	public void push(E element) {
		LLNode<E> newNode = new LLNode(element);
		newNode.setNext(top);
		top = newNode;
	}

	@Override
	public E pop() {
		E temp = top.getData();
		top = top.getNext();
		return temp;
	}

	@Override
	public E peek() {
		return top.getData();
	}

	@Override
	public boolean isEmpty() {
		return top == null;
	}

	@Override
	public boolean isFull() {
		return false;
	}
	
	public String toString() {
		StringBuilder stackStr = new StringBuilder("\n---------\n");
		LLNode<E> ptr = top;
		while (ptr != null) {
			stackStr.append(ptr.getData() + "\n");
			ptr = ptr.getNext();
		}
		return stackStr.toString();
	}

}

================
File: src/apps/AlphaBravoCharlie.java
================
package apps;

import adts.*;


public class AlphaBravoCharlie {

	public static void main(String[] args) {
		
		BinarySearchTree<String> abcTree =
				new BinarySearchTree<String>();
		
		abcTree.add("November");
		abcTree.add("Bravo");
		abcTree.add("Sierra");
		abcTree.add("Alpha");
		abcTree.add("Echo");
		abcTree.add("Romeo");
		abcTree.add("Tango");
		abcTree.add("India");
		abcTree.add("Yankee");
		
		System.out.println("PREORDER: ");
		abcTree.setTraversalType("pre");

		// etc.

		
		

	}

}

================
File: src/apps/Golfer.java
================
package apps;

public class Golfer implements Comparable<Golfer> {

	protected String name;
    protected int score;    

    public Golfer(String name, int score) {
    	this.name = name;
        this.score = score;
    }

    public String getName() {
        return name;
    }
  
    public int getScore() {
        return score;
    }

    public int compareTo(Golfer other) {
    	if (this.score < other.score)
    		return -1;
    	else
    		if (this.score == other.score)
    			return 0;
    	    else
    	    	return +1;
    }

    public String toString()  {
       return (score + ": " + name);
    }
}

================
File: src/apps/LeaderBoard.java
================
package apps;

import adts.BinarySearchTree;


public class LeaderBoard {
  
	public static void main(String[] args) {
		
		BinarySearchTree<Golfer> golfers = new BinarySearchTree<Golfer>();
		
		golfers.add(new Golfer("Hideki", 74));
		golfers.add(new Golfer("Cheyenne", 73));
		golfers.add(new Golfer("Matt", 77));
		golfers.add(new Golfer("Belén", 76));
		golfers.add(new Golfer("Brooks", 75));
		golfers.add(new Golfer("Natalie", 68));
		golfers.add(new Golfer("Xander", 71));
		golfers.add(new Golfer("Lexi", 79));
		golfers.add(new Golfer("Rory", 70));

	}
}

================
File: src/interfaces/BSTInterface.java
================
/* ----------------------------------------------------------------------------
* BSTInterface.java
*
* Tree objects of classes that implement this interface are unbounded and allow
* duplicate elements, but do not allow null elements.
*
* In-order, pre-order and post-order traversals are supported.
* 
* ---------------------------------------------------------------------------*/ 

package interfaces;

public interface BSTInterface<T extends Comparable<T>> {
	
  void add(T element);
	  
  boolean remove(T element);
  // remove the first item found in the tree such that item.compareTo(element) == 0
  // if no such item exists, return false
 
  boolean isEmpty();
  
  int size();
  
  boolean contains(T element);
  // return true if there is an item in the tree such that item.compareTo(element) == 0
  // otherwise return false
    
  T get(T element);
  // return the first item in the tree such that item.compareTo(element) == 0
  // if no such item exists, return null
  

}

================
File: src/interfaces/QueueInterface.java
================
package interfaces;

public interface QueueInterface<E> {

	void enqueue(E element);  // add an element to the queue - always at the end of the queue
	
	E dequeue();   // remove and return the front of the queue
	
	boolean isEmpty();
	
	boolean isFull();
	
}

================
File: src/interfaces/StackInterface.java
================
package interfaces;

public interface StackInterface<E> {

	void push(E element);  // add an element to the stack - always at the "top"
	
	E pop();   // remove and return the top of the stack
	
	E peek();  // return the top of the stack ... without removing
	
	boolean isEmpty();
	
	boolean isFull();
	
}

================
File: src/iterators/BSTIterator.java
================
package iterators;

import java.util.Iterator;
import java.util.ArrayList;

public class BSTIterator<E> implements Iterator<E> {
	
	protected ArrayList<E> travList;
	protected int size;
	protected int counter;

	public BSTIterator(ArrayList<E> travList) {
		this.travList = travList;
		this.size = travList.size();
		counter = 0;
	}

	@Override
	public boolean hasNext() {
		return counter < size;
	}

	@Override
	public E next() {
		return travList.get(counter++);
	}

}

================
File: src/nodes/BSTNode.java
================
package nodes;

public class BSTNode<E extends Comparable<E>> {

  protected E data;             // BST node payload
  protected BSTNode<E> left;    // reference to the left child node
  protected BSTNode<E> right;   // reference to the right child node

  public BSTNode(E data)  {
    this.data = data;
    left = null;
    right = null;
  }
 
  public void setData(E data) {
    this.data = data;
  }

  public E getData() {
    return data;
  }
 
  public void setLeft(BSTNode<E> link) {
    left = link;
  }

  public void setRight(BSTNode<E> link) {
    right = link;
  }

  public BSTNode<E> getLeft() {
    return left;
  }

  public BSTNode<E> getRight() {
    return right;
  }
  
}

================
File: src/nodes/DLLNode.java
================
package nodes;

public class DLLNode<E> {

	  private E data;
	  private DLLNode<E> next;
	  private DLLNode<E> prev;
	  
	  public DLLNode(E data) {
	    this.data = data;
	    next = null;
	    prev = null;
	  }
	 
	  public void setData(E data) {
	    this.data = data;
	  }

	  public E getData() {
	    return data;
	  }
	 
	  public void setNext(DLLNode<E> reference) {
	    this.next = reference;
	  }

	  public DLLNode<E> getNext() {
	    return next;
	  }

	  public void setPrev(DLLNode<E> reference) {
	    this.prev = reference;
	  }

	  public DLLNode<E> getPrev() {
	    return prev;
	  }
}

================
File: src/nodes/LLNode.java
================
package nodes;


public class LLNode<E> {
	
	private E data;
	private LLNode<E> next;
	
	public LLNode(E data) {
		this.data = data;
		next = null;
	}
	
	public E getData() {
		return data;
	}
	
	public void setData(E data) {
		this.data = data;
	}
	
	public LLNode<E> getNext() {
		return next;
	}
	
	public void setNext(LLNode<E> next) {
		this.next = next;
	}
}

================
File: src/ProgProjFive.iml
================
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>

================
File: .classpath
================
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" path="src"/>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
	<classpathentry kind="output" path="bin"/>
</classpath>

================
File: .project
================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>ProgProjFive</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jdt.core.javanature</nature>
	</natures>
</projectDescription>
